import os
from collections import ChainMap
from collections.abc import Sequence
from typing import NoReturn, Optional, Union

from . import c_ast
from .c_lexer import CLexer
from .c_parser import CParser
from .utils import Coord

__all__ = ("CContext", "parse", "preprocess_file", "parse_file")


class CParsingError(Exception):
    """Exception raised when something went wrong while parsing C."""

    def __init__(self, message: str, coord: Coord, *args: object) -> None:
        super().__init__(f"{coord}: {message}", *args)
        self.message = message
        self.coord = coord


class CContext:
    """High-level class that wraps the lexing/parsing process."""

    def __init__(self, filename: str = "<unknown>", parser_type: type[CParser] = CParser) -> None:
        self.filename = filename
        self.scope_stack: ChainMap[str, bool] = ChainMap()
        self.source = ""
        self.lexer = CLexer(self)
        self.parser = parser_type(self)

        self._ast: Optional[c_ast.File] = None

    @property
    def ast(self) -> c_ast.File:
        """ast: The AST generated by parsing a given source with `parse()`."""

        if self._ast is None:
            msg = "ast does not exist yet; parse() has not been run."
            raise AttributeError(msg)
        return self._ast

    def parse(self, source: str) -> None:
        self.source = source
        self._ast = self.parser.parse(self.lexer.tokenize(source))

    def error(self, message: str, location: Coord, *args: object) -> NoReturn:
        location.filename = self.filename
        raise CParsingError(message, location, *args)


def parse(source: str, filename: str = "<unknown>", parser_type: type[CParser] = CParser) -> "c_ast.File":
    context = CContext(filename, parser_type)
    context.parse(source)
    return context.ast


def preprocess_file(filename: str, cpp_path: str = "cpp", cpp_args: Sequence[str] = ()) -> str:
    """Preprocess a file using cpp.

    Arguments
    ---------
    filename: str
        The name of the file to preprocess.
    cpp_path: str, default="cpp"
        The path to the cpp compiler. Default is "cpp", which assumes it's already on PATH.
    cpp_args: Sequence[str], default=()
        A sequence of command line arguments for cpp, e.g. [r"-I../utils/fake_libc_include"]. Default is an empty
        tuple. Raw strings are recommended, especially when passing in paths.

    Returns
    -------
    str
        The preprocessed file's contents.

    Raises
    ------
    RuntimeError
        If the invocation of cpp failed. This should wrap the actual error.
    """

    import subprocess

    cmd = [cpp_path, *cpp_args, filename]

    try:
        # Note the use of universal_newlines to treat all newlines as \n for Python's purpose
        preprocessed_text = subprocess.check_output(cmd, universal_newlines=True)  # noqa: S603
    except OSError as exc:
        msg = 'Unable to invoke "cpp". Make sure its path was passed correctly.'
        raise RuntimeError(msg) from exc
    else:
        return preprocessed_text


def parse_file(
    file: Union[str, os.PathLike[str]],
    encoding: str = "utf-8",
    *,
    use_cpp: bool = False,
    cpp_path: str = "cpp",
    cpp_args: Sequence[str] = (),
    parser_type: type[CParser] = CParser,
) -> "c_ast.File":
    filename = os.fspath(file)
    if use_cpp:
        source = preprocess_file(filename, cpp_path, cpp_args)
    else:
        with open(file, encoding=encoding) as fp:
            source = fp.read()

    return parse(source, filename, parser_type=parser_type)
